<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fibre Channel Man</title>
    <style>
        canvas {
            border: 2px solid #00f;
            background-color: #222;
            display: block;
            width: 480px;
            height: 360px;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        h1 {
            color: #fff;
            margin: 0 0 10px 0;
            padding: 0;
        }
        #instructions {
            color: #fff;
            text-align: center;
            max-width: 480px;
            margin: 0 0 10px 0;
            padding: 0;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            padding: 0;
            margin: 0;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>Fibre Channel Man</h1>
        <div id="instructions">
            Use arrow keys to move Fibre Channel Man. Collect Data Packets (10 pts), Zoning Configs (50 pts), and Brocade Turbo Ports (power-up). Avoid Latency Ghosts unless turbo is activeâ€”then chase them for 200 pts each!
        </div>
        <canvas id="gameCanvas" width="480" height="360"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Sound effects
        const wakaSound = new Audio('http://commondatastorage.googleapis.com/codeskulptor-demos/DDR_assets/Kangaroo_MusiQue_-_The_Neverwritten_Role_Playing_Game.mp3');
        const powerUpSound = new Audio('powerup.mp3');
        const ghostEatenSound = new Audio('ghosteaten.mp3');
        const gameOverSound = new Audio('gameover.mp3');

        function playSoundForDuration(audio, durationMs) {
            audio.currentTime = 0;
            audio.play().catch(e => console.log("Audio play failed:", e));
            setTimeout(() => {
                audio.pause();
                audio.currentTime = 0;
            }, durationMs);
        }

        // Game settings
        const gridSize = 24;
        const tileCountX = 20;
        const tileCountY = 15;
        const playerSpeed = 200;
        const ghostSpeed = 250;
        const turboSpeed = 100;
        const vulnerableGhostSpeed = 400;

        let turboPulse = 0;
        let lastPulseTime = 0;

        // Fibre Channel Man
        let fibreMan = {
            x: 1,
            y: 1,
            dx: 0,
            dy: 0,
            turbo: false,
            turboTimer: 0,
            mouthAngle: 0,
            mouthOpen: true
        };

        // Latency Ghosts
        let ghosts = [
            { x: 18, y: 1, dx: -1, dy: 0, vulnerable: false },
            { x: 18, y: 13, dx: -1, dy: 0, vulnerable: false }
        ];

        // SAN Fabric Map (1 = wall, 0 = path, 2 = data packet, 3 = zoning config, 4 = turbo port)
        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,0,1],
            [1,2,1,1,2,1,1,1,2,2,2,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,2,1],
            [1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,1,2,2,1,1,1,2,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,4,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let score = 0;
        let lastUpdateTime = 0;
        let lastGhostUpdateTime = 0;

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') { fibreMan.dx = 0; fibreMan.dy = -1; }
            if (e.key === 'ArrowDown') { fibreMan.dx = 0; fibreMan.dy = 1; }
            if (e.key === 'ArrowLeft') { fibreMan.dx = -1; fibreMan.dy = 0; }
            if (e.key === 'ArrowRight') { fibreMan.dx = 1; fibreMan.dy = 0; }
        });

        // Function to draw a ghost
        function drawGhost(ghost) {
            const x = ghost.x * gridSize;
            const y = ghost.y * gridSize;
            const size = gridSize - 2;
            const color = ghost.vulnerable ? '#00f' : '#f00';

            // Ghost body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x + size / 2, y + size / 4, size / 2, Math.PI, 0, false); // Top semi-circle
            ctx.lineTo(x + size, y + size); // Right side down
            ctx.lineTo(x, y + size); // Left side down
            ctx.closePath();
            ctx.fill();

            // Wavy bottom
            ctx.beginPath();
            ctx.moveTo(x, y + size);
            for (let i = 0; i < 4; i++) {
                ctx.quadraticCurveTo(
                    x + (i * size / 3) + size / 6,
                    y + size + (i % 2 === 0 ? 4 : -4),
                    x + (i + 1) * size / 3,
                    y + size
                );
            }
            ctx.lineTo(x + size, y + size);
            ctx.closePath();
            ctx.fill();

            // Eyes
            const eyeOffsetX = size / 4;
            const eyeOffsetY = size / 4;
            const eyeSize = size / 6;

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x + size / 2 - eyeOffsetX, y + eyeOffsetY, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size / 2 + eyeOffsetX, y + eyeOffsetY, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + size / 2 - eyeOffsetX, y + eyeOffsetY, eyeSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + size / 2 + eyeOffsetX, y + eyeOffsetY, eyeSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Game loop
        function update(timestamp) {
            if (!lastUpdateTime) lastUpdateTime = timestamp;
            if (!lastGhostUpdateTime) lastGhostUpdateTime = timestamp;

            if (timestamp - lastPulseTime > 500) {
                turboPulse = (turboPulse + 1) % 2;
                lastPulseTime = timestamp;
            }

            let currentPlayerSpeed = fibreMan.turbo ? turboSpeed : playerSpeed;
            if (timestamp - lastUpdateTime > currentPlayerSpeed) {
                let newX = fibreMan.x + fibreMan.dx;
                let newY = fibreMan.y + fibreMan.dy;
                if (map[newY] && map[newY][newX] !== 1) {
                    fibreMan.x = newX;
                    fibreMan.y = newY;
                    fibreMan.mouthOpen = !fibreMan.mouthOpen;
                    if (map[newY][newX] === 2) {
                        map[newY][newX] = 0;
                        score += 10;
                        playSoundForDuration(wakaSound, 1000);
                    } else if (map[newY][newX] === 3) {
                        map[newY][newX] = 0;
                        score += 50;
                        playSoundForDuration(wakaSound, 1000);
                    } else if (map[newY][newX] === 4) {
                        map[newY][newX] = 0;
                        fibreMan.turbo = true;
                        fibreMan.turboTimer = timestamp;
                        ghosts.forEach(ghost => ghost.vulnerable = true);
                        powerUpSound.currentTime = 0;
                        powerUpSound.play().catch(e => console.log("Audio play failed:", e));
                    }
                }
                lastUpdateTime = timestamp;
            }

            if (fibreMan.turbo && timestamp - fibreMan.turboTimer > 5000) {
                fibreMan.turbo = false;
                ghosts.forEach(ghost => ghost.vulnerable = false);
            }

            if (timestamp - lastGhostUpdateTime > (ghosts[0].vulnerable ? vulnerableGhostSpeed : ghostSpeed)) {
                ghosts.forEach((ghost) => {
                    let dx = fibreMan.x - ghost.x;
                    let dy = fibreMan.y - ghost.y;
                    let possibleMoves = [
                        { dx: dx > 0 ? 1 : dx < 0 ? -1 : 0, dy: 0 },
                        { dx: 0, dy: dy > 0 ? 1 : dy < 0 ? -1 : 0 }
                    ];
                    possibleMoves.sort(() => Math.random() - 0.5);

                    let moved = false;
                    for (let move of possibleMoves) {
                        let newGX = Math.max(0, Math.min(tileCountX - 1, ghost.x + move.dx));
                        let newGY = Math.max(0, Math.min(tileCountY - 1, ghost.y + move.dy));
                        if (map[newGY] && map[newGY][newGX] !== 1) {
                            ghost.x = newGX;
                            ghost.y = newGY;
                            ghost.dx = move.dx;
                            ghost.dy = move.dy;
                            moved = true;
                            break;
                        }
                    }

                    if (!moved) {
                        let directions = [
                            { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
                        ];
                        for (let dir of directions) {
                            let newGX = Math.max(0, Math.min(tileCountX - 1, ghost.x + dir.dx));
                            let newGY = Math.max(0, Math.min(tileCountY - 1, ghost.y + dir.dy));
                            if (map[newGY] && map[newGY][newGX] !== 1) {
                                ghost.x = newGX;
                                ghost.y = newGY;
                                ghost.dx = dir.dx;
                                ghost.dy = dir.dy;
                                break;
                            }
                        }
                    }

                    if (ghost.x === fibreMan.x && ghost.y === fibreMan.y) {
                        if (ghost.vulnerable) {
                            ghost.x = 18;
                            ghost.y = 1;
                            score += 200;
                            ghostEatenSound.currentTime = 0;
                            ghostEatenSound.play().catch(e => console.log("Audio play failed:", e));
                        } else {
                            gameOverSound.currentTime = 0;
                            gameOverSound.play().catch(e => console.log("Audio play failed:", e));
                            alert(`Game Over! Latency caught you. Score: ${score}`);
                            resetGame();
                        }
                    }
                });
                lastGhostUpdateTime = timestamp;
            }

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 1) {
                        ctx.fillStyle = '#00f';
                        ctx.fillRect(x * gridSize, y * gridSize, gridSize - 1, gridSize - 1);
                    } else if (map[y][x] === 2) {
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(x * gridSize + gridSize / 2, y * gridSize + gridSize / 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (map[y][x] === 3) {
                        ctx.fillStyle = '#0f0';
                        ctx.beginPath();
                        ctx.moveTo(x * gridSize + gridSize / 2, y * gridSize + 4);
                        ctx.lineTo(x * gridSize + gridSize - 4, y * gridSize + gridSize / 2);
                        ctx.lineTo(x * gridSize + gridSize / 2, y * gridSize + gridSize - 4);
                        ctx.lineTo(x * gridSize + 4, y * gridSize + gridSize / 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('Z', x * gridSize + gridSize / 2, y * gridSize + gridSize / 2 + 4);
                    } else if (map[y][x] === 4) {
                        ctx.fillStyle = turboPulse ? '#ff0' : '#ffa500';
                        ctx.beginPath();
                        ctx.arc(x * gridSize + gridSize / 2, y * gridSize + gridSize / 2, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('T', x * gridSize + gridSize / 2, y * gridSize + gridSize / 2 + 4);
                    }
                }
            }

            ctx.fillStyle = fibreMan.turbo ? '#0ff' : '#ff0';
            ctx.beginPath();
            let startAngle, endAngle;
            if (fibreMan.dx === 1) { startAngle = fibreMan.mouthOpen ? 0.2 : 0.5; endAngle = fibreMan.mouthOpen ? 1.8 : 1.5; }
            else if (fibreMan.dx === -1) { startAngle = fibreMan.mouthOpen ? 1.2 : 1.5; endAngle = fibreMan.mouthOpen ? 2.8 : 2.5; }
            else if (fibreMan.dy === -1) { startAngle = fibreMan.mouthOpen ? 1.7 : 2; endAngle = fibreMan.mouthOpen ? 3.3 : 3; }
            else { startAngle = fibreMan.mouthOpen ? 0.7 : 1; endAngle = fibreMan.mouthOpen ? 2.3 : 2; }
            ctx.arc(fibreMan.x * gridSize + gridSize / 2, fibreMan.y * gridSize + gridSize / 2, gridSize / 2 - 2, startAngle * Math.PI, endAngle * Math.PI);
            ctx.lineTo(fibreMan.x * gridSize + gridSize / 2, fibreMan.y * gridSize + gridSize / 2);
            ctx.fill();

            ghosts.forEach(ghost => drawGhost(ghost));

            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 25);
        }

        function resetGame() {
            fibreMan = { x: 1, y: 1, dx: 0, dy: 0, turbo: false, turboTimer: 0, mouthAngle: 0, mouthOpen: true };
            ghosts = [
                { x: 18, y: 1, dx: -1, dy: 0, vulnerable: false },
                { x: 18, y: 13, dx: -1, dy: 0, vulnerable: false }
            ];
            score = 0;
            map[3][9] = 3;
            map[11][9] = 3;
            map[7][9] = 4;
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 0 && Math.random() > 0.3) map[y][x] = 2;
                }
            }
        }

        requestAnimationFrame(update);
    </script>
</body>
</html>