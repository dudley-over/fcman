<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fibre Channel Man</title>
    <style>
        canvas {
            border: 2px solid #00f; /* SAN fabric blue */
            background-color: #222; /* Dark SAN console vibe */
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        h1 {
            color: #fff;
            margin: 10px;
        }
        #instructions {
            color: #fff;
            text-align: center;
            max-width: 480px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Fibre Channel Man</h1>
    <div id="instructions">
        Use arrow keys to move Fibre Channel Man. Collect Data Packets (10 pts), Zoning Configs (50 pts), and Brocade Turbo Ports (power-up). Avoid Latency Ghosts unless turbo is activeâ€”then chase them for 200 pts each!
    </div>
    <canvas id="gameCanvas" width="480" height="480"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game settings
        const gridSize = 24;
        const tileCount = canvas.width / gridSize;
        const playerSpeed = 200; // Milliseconds per move
        const ghostSpeed = 250; // Normal ghost speed
        const turboSpeed = 100; // Turbo speed
        const vulnerableGhostSpeed = 400; // Vulnerable ghost speed

        // Fibre Channel Man
        let fibreMan = {
            x: 1,
            y: 1,
            dx: 0,
            dy: 0,
            turbo: false,
            turboTimer: 0,
            mouthAngle: 0, // For animation
            mouthOpen: true // Chomping state
        };

        // Latency Ghosts
        let ghosts = [
            { x: 18, y: 1, dx: -1, dy: 0, vulnerable: false },
            { x: 18, y: 18, dx: -1, dy: 0, vulnerable: false }
        ];

        // SAN Fabric Map (1 = wall, 0 = path, 2 = data packet, 3 = zoning config, 4 = turbo port)
        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,0,1],
            [1,2,1,1,2,1,1,1,2,2,2,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,2,1],
            [1,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,1,2,2,1,1,1,2,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,4,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let score = 0;
        let lastUpdateTime = 0;
        let lastGhostUpdateTime = 0;

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') { fibreMan.dx = 0; fibreMan.dy = -1; }
            if (e.key === 'ArrowDown') { fibreMan.dx = 0; fibreMan.dy = 1; }
            if (e.key === 'ArrowLeft') { fibreMan.dx = -1; fibreMan.dy = 0; }
            if (e.key === 'ArrowRight') { fibreMan.dx = 1; fibreMan.dy = 0; }
        });

        // Game loop
        function update(timestamp) {
            if (!lastUpdateTime) lastUpdateTime = timestamp;
            if (!lastGhostUpdateTime) lastGhostUpdateTime = timestamp;

            // Move Fibre Channel Man
            let currentPlayerSpeed = fibreMan.turbo ? turboSpeed : playerSpeed;
            if (timestamp - lastUpdateTime > currentPlayerSpeed) {
                let newX = fibreMan.x + fibreMan.dx;
                let newY = fibreMan.y + fibreMan.dy;
                if (map[newY] && map[newY][newX] !== 1) {
                    fibreMan.x = newX;
                    fibreMan.y = newY;
                    fibreMan.mouthOpen = !fibreMan.mouthOpen; // Toggle chomp
                    if (map[newY][newX] === 2) {
                        map[newY][newX] = 0;
                        score += 10;
                    } else if (map[newY][newX] === 3) {
                        map[newY][newX] = 0;
                        score += 50;
                    } else if (map[newY][newX] === 4) {
                        map[newY][newX] = 0;
                        fibreMan.turbo = true;
                        fibreMan.turboTimer = timestamp;
                        ghosts.forEach(ghost => ghost.vulnerable = true);
                    }
                }
                lastUpdateTime = timestamp;
            }

            // Turbo timer
            if (fibreMan.turbo && timestamp - fibreMan.turboTimer > 5000) {
                fibreMan.turbo = false;
                ghosts.forEach(ghost => ghost.vulnerable = false);
            }

            // Move Ghosts constantly
            if (timestamp - lastGhostUpdateTime > (ghosts[0].vulnerable ? vulnerableGhostSpeed : ghostSpeed)) {
                ghosts.forEach(ghost => {
                    // Chase logic
                    let dx = fibreMan.x - ghost.x;
                    let dy = fibreMan.y - ghost.y;
                    let possibleMoves = [
                        { dx: dx > 0 ? 1 : dx < 0 ? -1 : 0, dy: 0 },
                        { dx: 0, dy: dy > 0 ? 1 : dy < 0 ? -1 : 0 }
                    ];
                    // Shuffle moves to avoid predictable patterns
                    possibleMoves.sort(() => Math.random() - 0.5);

                    let moved = false;
                    for (let move of possibleMoves) {
                        let newGX = ghost.x + move.dx;
                        let newGY = ghost.y + move.dy;
                        if (map[newGY] && map[newGY][newGX] !== 1) {
                            ghost.x = newGX;
                            ghost.y = newGY;
                            ghost.dx = move.dx;
                            ghost.dy = move.dy;
                            moved = true;
                            break;
                        }
                    }

                    // Fallback: Random move if stuck
                    if (!moved) {
                        let directions = [
                            { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
                        ];
                        for (let dir of directions) {
                            let newGX = ghost.x + dir.dx;
                            let newGY = ghost.y + dir.dy;
                            if (map[newGY] && map[newGY][newGX] !== 1) {
                                ghost.x = newGX;
                                ghost.y = newGY;
                                ghost.dx = dir.dx;
                                ghost.dy = dir.dy;
                                break;
                            }
                        }
                    }

                    // Check collision
                    if (ghost.x === fibreMan.x && ghost.y === fibreMan.y) {
                        if (ghost.vulnerable) {
                            ghost.x = 18;
                            ghost.y = 1;
                            score += 200;
                        } else {
                            alert(`Game Over! Latency caught you. Score: ${score}`);
                            resetGame();
                        }
                    }
                });
                lastGhostUpdateTime = timestamp;
            }

            draw();
            requestAnimationFrame(update);
        }

        // Draw everything
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw SAN Fabric Map
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 1) {
                        ctx.fillStyle = '#00f';
                        ctx.fillRect(x * gridSize, y * gridSize, gridSize - 1, gridSize - 1);
                    } else if (map[y][x] === 2) {
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(x * gridSize + gridSize / 2, y * gridSize + gridSize / 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (map[y][x] === 3) {
                        ctx.fillStyle = '#0f0';
                        ctx.fillRect(x * gridSize + 6, y * gridSize + 6, gridSize - 12, gridSize - 12);
                    } else if (map[y][x] === 4) {
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(x * gridSize + gridSize / 2, y * gridSize + gridSize / 2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw Fibre Channel Man with chomping animation
            ctx.fillStyle = fibreMan.turbo ? '#0ff' : '#ff0';
            ctx.beginPath();
            let startAngle, endAngle;
            if (fibreMan.dx === 1) { startAngle = fibreMan.mouthOpen ? 0.2 : 0.5; endAngle = fibreMan.mouthOpen ? 1.8 : 1.5; } // Right
            else if (fibreMan.dx === -1) { startAngle = fibreMan.mouthOpen ? 1.2 : 1.5; endAngle = fibreMan.mouthOpen ? 2.8 : 2.5; } // Left
            else if (fibreMan.dy === -1) { startAngle = fibreMan.mouthOpen ? 1.7 : 2; endAngle = fibreMan.mouthOpen ? 3.3 : 3; } // Up
            else { startAngle = fibreMan.mouthOpen ? 0.7 : 1; endAngle = fibreMan.mouthOpen ? 2.3 : 2; } // Down or stationary
            ctx.arc(fibreMan.x * gridSize + gridSize / 2, fibreMan.y * gridSize + gridSize / 2, gridSize / 2 - 2, startAngle * Math.PI, endAngle * Math.PI);
            ctx.lineTo(fibreMan.x * gridSize + gridSize / 2, fibreMan.y * gridSize + gridSize / 2);
            ctx.fill();

            // Draw Latency Ghosts
            ghosts.forEach(ghost => {
                ctx.fillStyle = ghost.vulnerable ? '#00f' : '#f00';
                ctx.fillRect(ghost.x * gridSize, ghost.y * gridSize, gridSize - 2, gridSize - 2);
            });

            // Draw Score
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 10, 20);
        }

        // Reset game
        function resetGame() {
            fibreMan = { x: 1, y: 1, dx: 0, dy: 0, turbo: false, turboTimer: 0, mouthAngle: 0, mouthOpen: true };
            ghosts = [
                { x: 18, y: 1, dx: -1, dy: 0, vulnerable: false },
                { x: 18, y: 18, dx: -1, dy: 0, vulnerable: false }
            ];
            score = 0;
            map[3][9] = 3; // Zoning Config
            map[11][9] = 3; // Zoning Config
            map[7][9] = 4; // Turbo Port
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 0 && Math.random() > 0.3) map[y][x] = 2;
                }
            }
        }

        // Start the game
        requestAnimationFrame(update);
    </script>
</body>
</html>